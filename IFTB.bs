<pre class='metadata'>
Title: Binned Incremental Font Transfer
Shortname: IFTB
Status: WD
Prepare for TR: yes
Date: 2023-08-22
Group: webfontswg
Level: none
Markup Shorthands: css no
TR: https://www.w3.org/TR/RangeRequest/
ED: https://w3c.github.io/IFT/RangeRequest.html
Editor: Chris Lilley, W3C, https://svgees.us/, w3cid 1438
Editor: Myles C. Maxfield, Apple Inc., mmaxfield@apple.com, w3cid 77180
Editor: Garret Rieger, Google Inc., grieger@google.com, w3cid 73905
Abstract: This specification defines the range request variant of incremental font transfer.
          Incremental transfer allows clients to load only the portions of the font they actually need
          which speeds up font loads and reduces data transfer needed to load the fonts. A font can
          be loaded over multiple requests where each request incrementally adds additional data.
</pre>

<!--
    for things that are not in specref
    https://www.specref.org/
-->

<pre class=link-defaults>
spec:fetch; type:dfn; for:/; text:status
spec:fetch; type:dfn; for:/; text:response
</pre>

<style>
    .conform:hover {background: #31668f; color: white}
    .conform:target {padding: 2px; border: 2px solid #AAA; background: #31668f; color: white }
    </style>


Binned Incremental Font Transfer {#binned-incxfer}
===========================================================

Introduction {#iftb-intro}
-----------------------------

<em>This section is not normative.</em>

Binned Incremental Font Transfer, or IFTB, is a set of file formats that allow
an input font to be reprocessed into an <em>initial file</em> and a set of
corresponding <em>chunk files</em>.  IFTB imposes no server-side requirements
beyond the ability to transfer files. With this format, each glyph is assigned
by ID to one or more "bins", each of which has a corresponding "chunk" file
containing the outline data for those glyphs. Glyphs in bin 0 are always
included in the initially loaded file, which also contains all other OpenType
tables from the initial font.


The browser starts the transfer process by loading the initial font file. It
then uses an added IFTB table, together with the OpenType cmap table, to
determine which additional chunks, if any, are needed to render the current
content. It requests those chunks from the server, unpacks them as they arrive,
integrates the extracted glyph data into the specified glyf, loca, CFF, CFF2,
or gvar tables, and updates the IFTB table to record which chunks have been
integrated.  As the page content is updated the chunk identification and
loading process repeats.

When desired, the initial file can be "pre-loaded" with chunks for a particular
purpose, such as more efficient support of target script.

There are also two chunk file formats. The first is the uncompressed chunk
table structure described below. The second has the same content but with all
data following the header encoded with [[!RFC7932|brotli compression]]. Each
chunk is stored in its own file.

Font organization {#font-organization}
--------------------------------------

### Background ### {#font-organization-background}

<em>This section is not normative.</em>

There are two specified input file formats. The first is an uncompressed
variant of the OpenType "sfnt" format but with the version tag "IFTB" and an
extra "IFTB table. The second is the WOFF2 encoding of that format with all
tables in the same order.

Because the OpenType and WOFF2 formats are documented elsewhere, the initial
IFTB font format is specified in terms of changes to and restrictions on those
formats, including some specific OpenType tables.

### Introduction ### {#font-organization-introduction}

### Glyph Content ### {#iftb-glyph-content}

The term <dfn>outline table</dfn> is used to describe these four tables, which carry different types of
glyph outlines:

-   The <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/cff"><code>CFF</code></a>
    table
-   The <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/cff2"><code>CFF2</code></a>
    table
-   The <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/glyf"><code>glyf</code></a>
    table and its associated
    <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/loca"><code>loca</code></a>table
-   The <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/cff2"><code>gvar</code></a>
    table

An IFTB font must have either one CFF table, one CFF2 table, or one pair of glyf/loca tables.  A
variable glyf-table-based font will also have a gvar table.

### CFF and CFF2 Requirements and Recommendations ### {#iftb-cff-requirements}

When an IFTB-encoded font includes a CFF or CFF2 table:

1.   The CharStrings Index MUST be the last element of the table (followed by 0 padding to a four-byte
     word boundary).
2.   The CharStrings Index offset size MUST be 4.
3.   The offset of the CharStrings index from the start of the CFF table MUST be stored accurately in
     the relevant field of the IFTB table header.
4.   All GIDs in the binned set must be represented in the index from the start, with trailing
     zero-offset-change entries if needed.

An "empty" glyph in a CFF table MUST be encoded as a single "endchar" operator. An empty glyph in a
CFF2 table MUST be encoded as a zero-length string.

CFF or CFF2 subroutinization is compatible with the IFTB format. However, <em>naive</em>
subroutinization will tend to reduce chunk size while increasing the size of the initial file. Also,
WOFF2 has often been shown to compress a non-subroutinized font more effectively than its subroutinized
equivalent (at the cost of a significantly larger uncompressed file).  Therefore, it is recommended
that subroutinzation either be avoided, used moderately, or customized to the specific needs of IFTB.

### glyf/loca Requirements and Recommendations ### {#iftb-glyf-requirements}

When an IFTB-encoded font includes glyf and loca tables:

1.  The offset type of the loca table, specified in a field in the head table, MUST be the "Long"
     version.
2.  All GIDs in the binned set must be represented in the loca table from the start, with trailing
     zero-offset-change entries if needed.
3.  The tables must not be internally compressed.

### gvar Requirements and Recommendations ### {#iftb-gvar-requirements}

When an IFTB-encoded font includes a gvar table:

1.   The glyphVariationData set MUST be the last element in the table (followed by 0 padding to a
     four-byte word boundary.
2.   The offset type MUST be Offset32.
3.   All GIDs in the binned set MUST be represented in the array from the start, with trailing
     zero-offset-change entries if needed.

Note that the offset array itself is not required to be stored at any particular location in the table.

### Table Ordering ### {#iftb-table-ordering}

No two tables in an IFTB font should share a tag name.

In a CFF or CFF2 based IFTB font that table must be last. In a glyf/loca based IFTB font the last
tables must be glyf and loca in that order (loca following glyf is a requirement inherited from WOFF2).
If the font contains a gvar table it must come immediately before the glyf table.

There are no other ordering requirements. However, it is highly recommended that the IFTB and cmap
tables come early in the list and before any other lengthy table.

IFTB Font Formats {#iftb-font-formats}
--------------------------------------

The specification allows for two initial font formats:

1.   The uncompressed format is a slight variant of the OpenType "sfnt" format, but with a version tag
     of <code>IFTB</code> instead of <code>0x00010000</code> or <code>OTTO</code>
2.   The compressed format is a WOFF2 encoding of the uncompressed format with all tables in the same
     order.  The sfnt "flavor" in the WOFF2 header must accordingly also be <code>IFTB</code>

It is expected that the client will almost always download a WOFF2-encoded file, which it will then
unpack into the uncompressed format and modify as needed.

Before loading a copy of the uncompressed font into the browser, or making it available to some other
renderer, the version should be changed to <code>0x00010000</code> if the font has a glyf table or
<code>OTTO</code> if it has a CFF or CFF2 table.  However, if the file is cached it should be stored
with the <code>IFTB</code> version.  (The differing version is to help prevent an IFTB-encoded font
from being used accidentally as a standard font, which will generally result in blank spaces where some
glyphs should be rendered.)

IFTB Table {#iftb-table}
------------------------

The IFTB table contains information needed to determine what chunks are needed for a given font subset
description, and then to retrieve and integrate those chunks. It is similar in layout to analogous
OpenType tables, and is accordingly described in terms of the [OpenType Specification Data
Types](https://learn.microsoft.com/en-us/typography/opentype/spec/otff#data-types). As with OpenType
all fields use Big Endian byte orderng.

### IFTB Table Header ### {#iftb-table-header}

```
uint16     majorVersion   - set to 1
uint16     minorVersion   - set to 0
uint32     reserved       - not used, set to 0
uint32     id[4]          - ID uniquely identifying this IFTB font
uint16     flags          - not yet used
uint32     chunkCount     - number of bins in this IFTB font
uint32     glyphCount     - must match field in maxp table
Offset32   CFFCharStringsOffset  - 0 if glyf-based
Offset32   gidMapOffset
Offset32   chunkOffsetListOffset
Offset32   featureMapOffset
```

### IFTB Chunk Set ### {#iftb-chunk-set}

The header is followed by the chunk set:

```
uint8     chunkSet[(chunkCount + 7) / 8]
```

The chunk set is a bit array indicating whether the corresponding chunk is
present.  The bits for chunks 0 through 7 are in chunkSet[0], those for 8
through 15 are in chunkSet[1], and so on.  Within a byte the lowest chunk index
is represented by the 1s bit, then the 2s, then the 4s, and so on.

Because chunk 0 must always be included in the initial font file, its bit is
always set.  Other bits may also be set at the start if other chunks are <a
href="#iftb-preloading">preloaded</a>.  This array must be updated as chunks
are integrated into the font, and is the only part of the IFTB table that
changes after the initial encoding into IFTB format.

### IFTB Table Strings ### {#iftb-table-strings}

The chunkMap is directly followed by two strings in this format:

```
uint8      stringLength
int8       stringContent[stringLength]
uint8      terminator    - set to 0
```

The first string is the chunkFilesURI, which is a template for forming relative the URI for a chunk
file.  The string must contain substrings of "$1", "$2", "$3", "$4" and/or "$5", which must be replaced
with the corresponding hexidecimal digits of the chunk index ("$1" being the ones digit, "$2" being the
sixteens digit, and so on) to get the relative URI of the chunk. (This can then be combined with the
URL of the initial IFTB font file to produce the absolute URL of the chunk.)

The second string is the chunkRangeFileURI, which is also relative. This can be combined with the URL
of the initial IFTB font file to produce the absolute URL of the range file. The range file contains
all compressed chunk files in order, at offsets recorded in the chunkOffsetList.

### IFTB gidMap ### {#iftb-gidmap}

The gidMap maps each glyph, via GID, to a chunk index.

```
uint16     firstMappedGID
chunkIdx   chunkIndex[chunkCount - firstMappedGid + 1]
```

The <code>chunkIdx</code> data type is <code>uint8</code> when <code>chunkCount < 256</code> and
<code>uint16</code> otherwise.

When a GID is less than <code>firstMappedGID</code> it is implicitly mapped to chunk 0. For all others
the mapping is stored as chunkIndex[GID - firstMappedGID].

Note that the mapping for a GID corresponding to one or more Unicode codepoints has a different meaning
than a mapping for a GID without one. In normal operation a glyph of the latter type will be loaded
because it is included in a chunk corresponding to a different glyph with an associated codepoint. The
mapping of other GIDs is included for unusual cases in which a client needs to load a particular glyph
for its own reasons. (For example, a CFF font may have a CID mapping not completely replicated in the
<code>cmap</code> table.)

### IFTB chunkOffsetList ### {#iftb-chunkoffsetlist}

The chunkOffsetList is an array of chunk offsets indicating the start of the chunk in the chunk range
file:

```
Offset32    chunkOffset[chunkCount]
```

The offset of chunk <em>i</em> is stored at <code>chunkOffset[i-1]</code> (because chunk 0 is always
part of the initially loaded file), with chunkOffset[chunkCount] indicating the length of the last
chunk.

These offsets are normally only used when making range requests out of the chunk range file but can
also be used to lookup the lengths of compressed chunks in advance if needed.

### IFTB featureMap subtable ### {#iftb-table-featuremap}

The featureMap records what feature-specific chunks, if any, correspond to a codepoint-mapped chunk:

```
uint16         featureCount
FeatureRecord  featureRecord[featureCount]
ChunkMapRecord chunkMapRecord[varies]
```

A <code>FeatureRecord</code> consists of these fields:

```
uint32         featureTag
chunkIdx       firstIndex
chunkIdx       chunkMapCount
```

As in the gidMap the <code>chunkIdx</code> data type is a <code>uint8</code> when <code>chunkCount <=
256</code> and a <code>uint16</code> otherwise.

The <code>featureRecord</code> array must be sorted by <code>featureTag</code> with any feature tag
occurring at most once.  Only layout features that have their own chunks should be have a
<code>FeatureRecord</code> <code>firstIndex</code> is the chunk index of the first chunk specific to
this feature. The number of feature-specific chunks will then be <code>chunkRecordCount</code> which
must be at least 1. The chunk correspondence is encoded in <code>ChunkMapRecords</code>

```
chunkIdx      firstChunk
chunkIdx      lastChunk
```

The <code>chunkMapRecord</code> array contains as many entries as the sum of <code>chunkMapCount</code>
fields in the <code>featureRecord</code> array, with <code>chunkMapRecord[0]</code> corresponding to
the first chunk of <code>featureRecord[0]</code>,
<code>chunkMapRecord[featureRecord[0].chunkMapCount]</code> corresponding to the first chunk of
<code>featureRecord[1]</code>, <code>chunkMapRecord[featureRecord[0].chunkMapCount +
chunkMapRecord[featureRecord[1].chunkMapCount]</code> corresponding to the first chunk of
<code>featureRecord[2]</code>, and so on.

<code>firstChunk</code> must be less than or equal to <code>lastChunk</code>. If <code>featureTag</code>
is part of the set of layout features in the font subset description, and any of firstChunk through
lastChunk are required by the set of codepoints in that description, then that feature-specfic chunk
must also be loaded.

### Optional IFTB Table Values ### {#iftb-table-optional}

If a particular IFTB-encoded font does not include a range file the chunkRangeFileURI string must be
empty. The <code>chunkOffsetList</code> can either be included for reference or omitted by setting the
<code>chunkOffsetListOffset</code> field to 0.  If a particular font does not include separate chunk
files the <code>chunkFilesURI</code> field must be empty.

When an IFTB format font has no feature-specific chunks the <code>featureMapOffset</code> must be 0.

IFTB Chunk Formats {#iftb-chunk-formats}
----------------------------------------

### The Uncompressed Chunk Format (IFTC) ### {#iftc-format}

An uncompressed chunk string, which is normally produced by decoding a compressed chunk, has these
fields:

```
uint32        version     - must be "IFTC" tag
uint32        reserved    - must be 0
uint32        id[4]       - unique id -- must match same fields in IFTB table
uint32        chunkIndex  - (uint32) for potential future extensions
uint32        length      - the length of the (uncompressed) chunk string
uint32        glyphCount  - the number of glyphs encoded in the chunk
uint8         tableCount  - the number of tables the chunk has data for (must be 1 or 2)
uint16        GIDs[glyphCount]    - an array of GIDs included in the chunk
uint32        tables[tableCount]  - an array of tables (by tag) included in the chunk.
Offset32      offsets[glyphCount * tableCount] - an array of offsets of glyph data,
                                                 with the first glyphCount offsets corresponding
                                                 to table 1 and (if present) the second glyphCount
                                                 offsets corresponding to table 2. All offsets are
                                                 from the start of the table.
uint8         glyphData[varies]  - the actual glyph data picked out by the offsets.
```

<code>tableCount</code> will be 2 only when there is both a <code>glyf</code> and a <code>gvar</code>
table.  Otherwise <code>tableCount</code> will be 1 and the table will be <code>CFF </code>
<code>CFF2</code> or <code>glyf</code>

### The Compressed Chunk Format (IFTZ) ### {#iftz-format}

A compressed chunk string is the same as an uncompressed chunk string except:

1.  The <code>version</code> is <code>IFTZ</code>.
2.  All data after the <code>length</code> field is [[!RFC7932|brotli compressed]]

The compressed chunk contains no indication of its (compressed) length, but that length is encoded
in the <code>chunkOffsetList</code> of the IFTB table.

Browser Behaviors {#iftb-browser-behaviors}
-------------------------------------------

### First Request ### {#iftb-browser-behaviors-first-request}

1.   The browser loads a font file and identifies it as an IFTB font by its "sfnt" header version (in
     the uncompressed case) or by its WOFF2 "flavor" (in the compressed case).  These are the first
     and second 4-byte words in the files respectively.
2.   In the compressed case, it decodes the WOFF2 into its corresponding OTF (The browser can 
     optionally isolate the IFTB and cmap tables early in the stream to proceed before the remaining
     font content downloads.)
3.   The browser determines the initial font subset description corresponding to the content it needs
     to render using the font.  (IFTB does not provide subsetting of variable axes, so this is just
     the sets of codepoints and layout features.)
4.   The browser maps each codepoint in the font subset description to a GID using the cmap table. It
     then maps that GID to a chunk index using GIDMap of the IFTB table. That index is added to a
     "chunk set" (which could be a bitmap or std::vector<bool> indexed by chunk index.
5.   The browser then look up each layout feature in the font subset description in the IFTB table
     featureTable. That table maps the initial GID-mapped chunks to higher-indexed feature-specific
     chunks. If any chunk in the set maps to a feature-specific-chunk the latter is added to the set.
6.   The browser subtracts the list of already-included chunks recorded in the IFTB ChunkMap from the
     chunk set.  If no chunks remain, the process skips to step XXX.
7.   At this point there are two options for retrieving chunk contents:

     Load each needed chunk using individual files:
     1.  Calculate the hex string for the chunk index
     2.  Get the chunkFilesURI string from the IFTB table and substitute "$1", "$2", ... with
          the corresponding hex digit.
     3.  Combine the relative URI with the URL of the original font to get the URL for the chunk.
     4.  Request that file via HTTP.

     Load each needed chunk from the range file:
     1.  Get the chunkRangeFileURI from the string IFTB table.
     2.  Combine that URI with the URL of the original font to get the URL for the range file.
     3.  Get the byte range for each chunk from the chunkOffsetTable in the IFTB table.
     4.  Form a HTTP range request for those byte ranges using the combined URL.
8.   Decompress each retrieved chunk content.
9.   Merge the glyph contents in all of the chunks into the corresponding tables, reallocating the
     memory for the font if necessary. (All of the relevant tables use an offset array and concatenated
     glyph data convention.)
10.  Update the IFTB table to record the chunks added (the table will not change in length).
11.  Update the "sfnt" headers for the correct offsets, sizes, and (if needed by the client) checksums.
     (Only the trailing CFF, CFF2, glyf, loca and or gvar tables will change in size or location.) Also
     update the checksumAdjustment in the head table (if needed by the client).
12.  If caching, store the file at this point.
13.  Update the SFNT version to 0x00010000 (for a glyf table) or "OTTO" (for a CFF or CFF2 table) and
     also the head table checksumAdjustment again (if needed by the client).
14. Render the text with the updated font.

### Subsequent Requests ### {#iftb-browser-behaviors-subsequent-requests}

Subsequent requests proceed like the initial request starting at step 3.

IFTB Encoding {#iftb-encoding}
------------------------------

An input font is encoded in the IFTB format using an encoder as a separate, initial step.  If any other
subsetting (such as removing or reducing variable axes, or removing glyphs that are not needed) is
desired the input font should be subset prior to IFTB encoding with an appropriate tool.

With IFTB only glyph data is transferred incrementally. The encoded file also
"retains" GIDS the input font's GIDs, and therefore most tables can simply be
copied from the source font.  However, an encoder can also deserialize and
reserialize tables if it desires.

The details of the encoding process may differ by encoder and are beyond the scope of this document.
However, all mappings of codepoints (though GIDs) to bins and bins to feature-specific bins must meet
this closure requirement:

* The set of glyphs contained in the chunks loaded through the GID and feature maps must be a superset
    of those in the GID closure of the font subset description.

The encoder has three options for addressing with joint dependencies on individual glyphs:

1.   If a glyph is needed in more than one initial "trial" bin, those bins can be combined.
2.   Alternatively, the glyph can be included in both bins, or more than two bins.  (The glyph will
     only be mapped to one chunk in the <code>gidMap</code>, and special care must be taken about which
     chunk it maps to if it has an associated codepoint. However, the encoder is free to include it in
     other bins as long as the closure requirement is met.)
3.   If a glyph is needed in more than a few trial bins, or is otherwise complicating the binning
     process, it can be moved to bin 0 where it will always be included in the initially loaded file.

Glyph Bin Locality {#iftb-bin-locality}
---------------------------------------

An IFTB-encoded font may have as few as fifty or as many as two thousand bins.
Higher numbers of bins may result in unacceptable overhead and diminishing
returns. Regardless of the particular number, however, if glyphs are randomly
distributed among bins most of them might need to be loaded in order to render
a typical document.

Therefore it is vital to efficiency to distribute glyphs among bins so that
fewer bins are needed in a typical case.  The most basic strategy will be
assigning glyphs to bins by frequency of use, so that more frequently needed
glyphs will be concentrated together in bins. However, <em>just</em> ordering
by frequency is often a mistake, because there are many more documents that
need, for example, glyphs for writing Korean or glyphs for writing Greek than
there are documents that need both.

Therefore, it is best to start with an idea of how the encoded font will typically be used. One primary
use-case for font augmentation is for use with CJK-oriented fonts. A given font might "specialize" in
a given script or language subset (e.g. traditional Chinese vs Hong Kong Chinese) whereas other fonts
might be general. If a font will be used with one language or dialect it can be encoded with frequency
data for that specific application.

If the font will be used with multiple languages and/or dialects, however, one approach is to obtain
frequency data for each and then establish a high-frequency-glyph "cut-off" for each.  You can then
determine the intersecting sets of high frequency glyphs and ensure these wind up in their own chunks.
For example, if you are encoding for Japanese, Korean, and traditional Chinese, you may choose to
consider the top 3000, 1800, and 2300 glyphs of each respectively to be high-frequency. You can then
form a group of high frequency glyphs in all three sets, a group in both Japanese and Korean, a group
in both Japanese and Chinese, a group in both Korean and Chinese, and then the remaining glyphs for
each individual language, and encode each group separately (in combined order of frequency, if
available, and in order by frequency in one language otherwise) in their own set of chunks. That way
rendering a Chinese document can load high-frequency Chinese glyphs while avoiding Korean glyphs and
vice-versa

The assignment of high frequency glyphs to bins will have the most effect on performance.
Low-frequency glyphs are least important, but there is still some locality to be exploited. For
example, there is a set of Unicode codepoints used for rendering boxes. These are rarely used, but need
one is predictive of needing the others.  As such glyphs tend to be grouped by codepoint value anyway,
it is often sufficient to order low-frequency glyphs by codepoint when assigning them to bins.

In between are the medium-frequency codepoints. When those codepoints are specific to a language or
script, they can just be grouped and ordered by frequency in that language or script.  (This is true,
broadly speaking, of many Hangul glyphs for writing Korean.) When multiple languages share
medium-frequency codepoints things become trickier. One strategy is to pick one language or script and
order the medium-frequency codepoints according to its frequency, either letting the others suffer in
performance somewhat or, if desired, granting one or more their own IFTB encodings.

Preloadng {#iftb-preloading}
----------------------------

Requesting, waiting for, and integrating chunks into an IFTB-encoded font all involve some overhead
compared with loading an initial file that already includes that data. (The size of glyph data in a
compressed chunk will typically be a bit larger than its size in a WOFF2-encoded initital file, as
Brotli compression is very good at recognizing and making use of common content, and chunks tend to
have relatively less content.)  Therefore it is best to include those glyphs that are most frequently
used in the initial file.

If a font has a single purpose, one may choose to include the high frequency codepoints in chunk 0.
When it has multiple purposes one has the option of encoding for each purpose separately, with the
high frequency codepoints for a given purpose in chunk 0 of its respective encoding.  However, that
approach has several disadvantages related to file sizes and caching: The data for the entire font is
repeated in each encoding. The number of files used is multiplied. And perhaps most importantly,
requests for chunks are spread over the different versions, increasing the probability of a CDN cache
miss for a given encoding. (So, for example, the caching chunks for a less common purpose won't benefit
from the more frequent requests for chunks, and therefore the higher chance of a cache hit, for a more
common purpose.)

Instead of encoding separate copies, it will often be better to encode the font for mulitple uses, as
described in the last section, and then to <em>pre-load</em> chunks for a given use into an initial
copy of the font. Preloading is doing on the server-side something close to what the client would do
after first loading the font: The chunks are "loaded", their contents are integrated into the relevant
tables, and the IFTB chunk set is updated. After this, the file is re-encoded in WOFF2 format.  Because
the URIs for chunks and for the range file are relative, as long as the preloaded copy of the initial
font is served in the same directory as the original copy, subsequent chunks will be loaded in the same
way.
